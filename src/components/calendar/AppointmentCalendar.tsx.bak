import React, { useState, useEffect, useRef } from 'react';
import FullCalendar from '@fullcalendar/react';
import dayGridPlugin from '@fullcalendar/daygrid';
import timeGridPlugin from '@fullcalendar/timegrid';
import interactionPlugin from '@fullcalendar/interaction';
import listPlugin from '@fullcalendar/list';
import frLocale from '@fullcalendar/core/locales/fr';
import { appointmentService } from '../../services/api';
import { Appointment } from '../../types';
import NewAppointmentModal from '../appointments/NewAppointmentModal';
import { EventClickArg, DateSelectArg, EventChangeArg } from '@fullcalendar/core';
import { enhanceCalendar, enhanceCurrentTimeIndicator, enhanceMonthView, hideWeekdayNames } from '../../utils/calendarEnhancer';
import '../../calendar-day-headers.css';

interface AppointmentCalendarProps {
  onAppointmentAdded?: () => void;
  onAppointmentUpdated?: () => void;
  onAppointmentDeleted?: () => void;
  statusFilter?: string | null;
  className?: string;
}

const AppointmentCalendar: React.FC<AppointmentCalendarProps> = ({ 
  onAppointmentUpdated,
  statusFilter,
  className
}) => {
  const calendarRef = useRef<any>(null);
  const [appointments, setAppointments] = useState<Appointment[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [isNewAppointmentModalOpen, setIsNewAppointmentModalOpen] = useState<boolean>(false);
  const [isEditAppointmentModalOpen, setIsEditAppointmentModalOpen] = useState<boolean>(false);
  const [selectedDate, setSelectedDate] = useState<string>('');
  const [selectedTime, setSelectedTime] = useState<string>('');
  const [selectedAppointment, setSelectedAppointment] = useState<Appointment | null>(null);
  const [calendarView, setCalendarView] = useState('timeGridWeek');
  const [isMonthView, setIsMonthView] = useState(false); // Nouvel état pour suivre si on est en vue mensuelle

  // Charger les rendez-vous
  useEffect(() => {
    loadAppointments();
    
    // Référence pour stocker le timestamp du dernier chargement
    const lastLoadRef = { time: 0 };
    
    // Configurer un rechargement périodique avec un intervalle plus long (toutes les 60 secondes)
    const interval = setInterval(() => {
      loadAppointments();
    }, 60000); // Augmenté à 60 secondes pour réduire la charge
    
    // Écouter l'événement focus pour recharger les données lorsque l'utilisateur revient à l'onglet
    const handleFocus = () => {
      // Éviter de recharger trop souvent
      const now = Date.now();
      if (now - lastLoadRef.time > 30000) { // Au moins 30 secondes entre les rechargements
        lastLoadRef.time = now;
        console.log('Fenêtre a le focus, rechargement des rendez-vous...');
        loadAppointments();
      }
    };
    
    // Écouter les événements personnalisés pour les changements de rendez-vous
    const handleAppointmentCreated = () => {
      console.log('Événement appointmentCreated détecté, rechargement des rendez-vous...');
      loadAppointments();
    };
    
    const handleAppointmentUpdated = () => {
      console.log('Événement appointmentUpdated détecté, rechargement des rendez-vous...');
      loadAppointments();
    };
    
    const handleAppointmentDeleted = () => {
      console.log('Événement appointmentDeleted détecté, rechargement des rendez-vous...');
      loadAppointments();
    };
    
    window.addEventListener('focus', handleFocus);
    window.addEventListener('appointmentCreated', handleAppointmentCreated);
    window.addEventListener('appointmentUpdated', handleAppointmentUpdated);
    window.addEventListener('appointmentDeleted', handleAppointmentDeleted);
    
    // Nettoyer lors du démontage du composant
    return () => {
      clearInterval(interval);
      window.removeEventListener('focus', handleFocus);
      window.removeEventListener('appointmentCreated', handleAppointmentCreated);
      window.removeEventListener('appointmentUpdated', handleAppointmentUpdated);
      window.removeEventListener('appointmentDeleted', handleAppointmentDeleted);
    };
  }, []);
  
  // Effectuer un changement de vue en fonction de la largeur d'écran
  useEffect(() => {
    const handleResize = () => {
      if (window.innerWidth < 640) {
        // Sur mobile, utiliser la vue jour ou liste
        if (calendarView !== 'timeGridDay' && calendarView !== 'listWeek') {
          setCalendarView('timeGridDay');
        }
      } else {
        // Sur desktop, conserver la vue semaine par défaut si c'était une vue mobile
        if (calendarView === 'timeGridDay') {
          setCalendarView('timeGridWeek');
        }
      }
    };

    handleResize(); // Appliquer au chargement
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [calendarView]);
  
  // Détecter le changement de vue pour adapter le format des entêtes
  const handleViewChange = (viewInfo: any) => {
    const isMonthViewActive = viewInfo.view.type === 'dayGridMonth';
    setIsMonthView(isMonthViewActive);
    setCalendarView(viewInfo.view.type);
    console.log('Vue du calendrier changée:', viewInfo.view.type, 'isMonthView:', isMonthViewActive);
  };    // Améliorer le calendrier après le rendu
  useEffect(() => {
    if (!loading) {
      // Exécuter immédiatement pour éviter tout délai inutile
      enhanceCalendar(isMonthView);
      enhanceCurrentTimeIndicator();
      hideWeekdayNames(); // Masquer complètement les noms des jours dans toutes les vues
    }
  }, [loading, appointments, isMonthView]);
  const loadAppointments = async () => {
    console.log('Chargement des rendez-vous...');
    try {
      // Ne pas définir loading=true si déjà en cours de chargement
      if (!loading) {
        setLoading(true);
      }
      setError(null);
      
      // Timeout plus court pour éviter un blocage
      const timeoutPromise = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Délai dépassé')), 1000));
      
      const dataPromise = appointmentService.getAll();
      
      // Désactiver le chargement après un court délai pour éviter un blocage de l'UI
      const loadingTimer = setTimeout(() => {
        setLoading(false);
      }, 500);
      
      // Course entre le chargement des données et le timeout
      const data = await Promise.race([dataPromise, timeoutPromise])
        .catch(err => {
          console.warn('Timeout ou erreur de chargement:', err);
          clearTimeout(loadingTimer);
          return []; // Retourne un tableau vide en cas d'échec
        }) as Appointment[];
      
      // Nettoyage du timer si les données arrivent avant
      clearTimeout(loadingTimer);
      
      console.log('Rendez-vous chargés:', data?.length || 0);
      if (Array.isArray(data)) {
        setAppointments(data);
      }
      
      // Désactiver le chargement immédiatement après traitement des données
      setLoading(false);
    } catch (err) {
      setError('Erreur lors du chargement des rendez-vous');
      console.error('Erreur lors du chargement des rendez-vous:', err);
      setLoading(false);
    }
  };
  
  // Convertir les rendez-vous pour FullCalendar
  const calendarEvents = appointments
    .filter(appointment => {
      // Filtrer les rendez-vous sans date ou heure valide
      const isValid = appointment && appointment.date && appointment.time;
      
      // Filtrer par statut si un filtre est actif
      if (statusFilter && isValid) {
        return appointment.status === statusFilter;
      }
      
      return isValid;
    })
    .map(appointment => {
      // Normaliser le format de la date (si nécessaire)
      let formattedDate = appointment.date;
      if (formattedDate.includes('T')) {
        formattedDate = formattedDate.split('T')[0];
      }
      
      // Normaliser le format de l'heure (si nécessaire)
      let formattedTime = appointment.time;
      if (!formattedTime.includes(':')) {
        formattedTime = `${formattedTime}:00`;
      }
      
      const service = appointment.Service || 
                      (appointment.serviceName ? { name: appointment.serviceName, duration: appointment.duration || 60 } : null);
      const serviceName = service ? service.name : 'Sans service';
      const duration = service ? service.duration : 60;
      
      // Log pour débogage
      console.log('Création d\'événement calendrier:', { 
        id: appointment.id,
        date: formattedDate,
        time: formattedTime,
        clientName: appointment.clientName,
        service: serviceName
      });
      
      return {
        id: appointment.id.toString(),
        title: `${appointment.clientName} - ${serviceName}`,
        start: `${formattedDate}T${formattedTime}`,
        end: calculateEndTime(formattedDate, formattedTime, duration),
        extendedProps: {
          appointmentData: appointment,
          status: appointment.status,
          clientName: appointment.clientName,
          serviceName: serviceName,
          time: formattedTime
        },  
        backgroundColor: getStatusColor(appointment.status),
        borderLeft: `4px solid ${getStatusColor(appointment.status)}`,
        classNames: [
          'event-status-' + (appointment.status || 'pending'),
          'hover:shadow-md'
        ]
      };
    });
    
  // Calculer l'heure de fin en fonction de la durée du service
  function calculateEndTime(date: string, time: string, durationMinutes: number): string {
    // Vérifier si la date et l'heure sont valides
    if (!date || !time || date === 'Invalid Date' || time === 'Invalid Date') {
      // Retourner une chaîne vide ou la date actuelle comme solution de secours
      console.warn('Date ou heure invalide pour le calcul de fin:', { date, time });
      const now = new Date();
      return now.toISOString();
    }
    
    try {
      // Normaliser le format de la date (YYYY-MM-DD)
      if (date.includes('T')) {
        date = date.split('T')[0];
      }
      
      // S'assurer que le format de l'heure est correct (HH:MM)
      if (!time.includes(':')) {
        time = `${time}:00`;
      }
      
      console.log('Calcul d\'heure de fin avec:', { date, time });
      const startTime = new Date(`${date}T${time}`);
      
      // Vérifier si la date est valide
      if (isNaN(startTime.getTime())) {
        console.error('Date invalide après création de l\'objet Date:', { date, time });
        const now = new Date();
        return now.toISOString();
      }
      
      const endTime = new Date(startTime.getTime() + durationMinutes * 60000);
      return endTime.toISOString();
    } catch (error) {
      console.error('Erreur lors du calcul de l\'heure de fin:', error);
      // Retourner une chaîne vide ou la date actuelle comme solution de secours
      const now = new Date();
      return now.toISOString();
    }
  }

  // Déterminer la couleur en fonction du statut du rendez-vous
  function getStatusColor(status: string): string {
    switch (status) {
      case 'confirmed': return '#4CAF50'; // Vert
      case 'pending': return '#FF9800'; // Orange
      case 'cancelled': return '#F44336'; // Rouge
      case 'completed': return '#2196F3'; // Bleu
      default: return '#9E9E9E'; // Gris
    }
  }

  // Gérer la sélection d'une plage horaire dans le calendrier
  const handleDateSelect = (selectInfo: DateSelectArg) => {
    const startDate = new Date(selectInfo.start);
    
    // Formatter la date et l'heure
    const formattedDate = startDate.toISOString().split('T')[0];
    const formattedTime = startDate.toTimeString().slice(0, 5);
    
    console.log('Plage horaire sélectionnée:', { 
      start: selectInfo.start, 
      formattedDate, 
      formattedTime 
    });
    
    // Stocker les valeurs formatées
    setSelectedDate(formattedDate);
    setSelectedTime(formattedTime);
    
    // Ouvrir la modal pour créer un rendez-vous
    setIsNewAppointmentModalOpen(true);
  };

  // Gérer le clic sur un événement existant
  const handleEventClick = (clickInfo: EventClickArg) => {
    const appointmentData = clickInfo.event.extendedProps.appointmentData as Appointment;
    setSelectedAppointment(appointmentData);
    setIsEditAppointmentModalOpen(true);
  };

  // Gérer le changement d'un événement (déplacer ou redimensionner)
  const handleEventChange = async (changeInfo: EventChangeArg) => {
    try {
      const appointmentData = changeInfo.event.extendedProps.appointmentData as Appointment;
      const newStartTime = changeInfo.event.start;
      
      console.log('Événement déplacé:', {
        eventId: changeInfo.event.id,
        oldDate: appointmentData.date,
        oldTime: appointmentData.time,
        newStartTime: newStartTime ? newStartTime.toString() : null
      });
      
      if (newStartTime) {
        // Utiliser directement les informations fournies par FullCalendar
        // sans convertir en UTC pour éviter le problème de fuseau horaire
        const localDate = newStartTime;
        
        // Convertir en format adapté à notre API
        const formattedDate = localDate.toLocaleDateString('fr-CA'); // Format YYYY-MM-DD
        const hours = String(localDate.getHours()).padStart(2, '0');
        const minutes = String(localDate.getMinutes()).padStart(2, '0');
        const formattedTime = `${hours}:${minutes}`;
        
        console.log('Nouvelle date/heure formatée:', { 
          formattedDate, 
          formattedTime,
          rawLocalDate: localDate.toString() 
        });
        
        const updatedAppointment = {
          ...appointmentData,
          date: formattedDate,
          time: formattedTime
        };
        
        await appointmentService.update(appointmentData.id.toString(), updatedAppointment);
        
        if (onAppointmentUpdated) {
          onAppointmentUpdated();
        }
        
        loadAppointments();
      }
    } catch (err) {
      console.error('Erreur lors de la mise à jour du rendez-vous:', err);
      setError('Erreur lors de la mise à jour du rendez-vous');
      // Recharger les rendez-vous pour annuler le changement visuel
      loadAppointments();
    }
  };  // Assurer que le calendrier s'affiche même sans données
  const hasInitialized = useRef(false);
  
  useEffect(() => {
    // Passer automatiquement à l'état non-loading après un court délai
    // pour éviter d'attendre indéfiniment
    if (loading && !hasInitialized.current) {
      const forceLoadTimeout = setTimeout(() => {
        hasInitialized.current = true;
        setLoading(false);
      }, 800); // Temps plus court pour éviter le blocage
      
      return () => clearTimeout(forceLoadTimeout);
    }
    
    // Forcer le passage à non-loading après un délai plus court
    const cleanupTimeout = setTimeout(() => {
      if (loading) {
        setLoading(false);
      }
    }, 1000); // Temps plus court
    
    return () => clearTimeout(cleanupTimeout);
  }, [loading]);
  
  return (
    <div className={`appointment-calendar flex flex-col h-full w-full min-h-0 ${className || ''}`}>
      {error && (
        <div className="bg-red-100 dark:bg-red-900/20 border-l-4 border-red-500 dark:border-red-700 text-red-700 dark:text-red-400 p-2 mb-1 rounded-r-lg shadow-sm animate-fadeIn" role="alert">
          <p>{error}</p>
        </div>
      )}
      {loading && !hasInitialized.current ? (
        <div className="flex justify-center items-center h-32">
          <div className="flex flex-col items-center">
            <div className="animate-spin rounded-full h-10 w-10 border-t-2 border-r-2 border-b-2 border-blue-500 dark:border-blue-400 shadow-md"></div>
            <p className="mt-2 text-gray-500 dark:text-gray-400 animate-pulse text-sm">Chargement du calendrier...</p>
          </div>
        </div>
      ) : (        <div className="calendar-container flex-1 min-h-0 w-full rounded-lg overflow-hidden">          <FullCalendar
            ref={calendarRef}
            plugins={[dayGridPlugin, timeGridPlugin, interactionPlugin, listPlugin]}
            initialView={calendarView}
            headerToolbar={{
              left: 'prev,next today',
              center: 'title',
              right: 'dayGridMonth,timeGridWeek,timeGridDay,listWeek'
            }}
            buttonText={{
              today: 'Aujourd\'hui',
              month: 'Mois',
              week: 'Semaine',
              day: 'Jour',
              list: 'Planning'
            }}
            contentHeight="auto"
            themeSystem="standard"
            navLinks={true}
            selectable={true}
            locale={frLocale}
            editable={true}
            selectMirror={true}
            eventInteractive={true}
            dayMaxEvents={6}
            weekends={true}
            events={calendarEvents}
            height="100%"
            allDaySlot={false}
            nowIndicator={true}            dayHeaderClassNames="text-sm font-medium text-gray-700 dark:text-gray-300 py-2"
            slotLabelClassNames="text-gray-500 dark:text-gray-400 text-xs font-medium"
            viewClassNames="animate-fadeIn transition-opacity duration-300"
            handleWindowResize={true}            slotMinTime="08:00:00"
            slotMaxTime="11:00:00"
            slotDuration="00:15:00"
            expandRows={true}
            stickyHeaderDates={true}
            slotEventOverlap={false}
            select={handleDateSelect}
            eventClick={handleEventClick}
            eventChange={handleEventChange}
            {/* Déclencher une fonction lors du changement de vue */}            datesSet={(dateInfo: any) => {
              // Détecter si nous sommes en vue mensuelle
              const isMonthViewActive = dateInfo.view.type === 'dayGridMonth';
              setIsMonthView(isMonthViewActive);
              setCalendarView(dateInfo.view.type);
              console.log('Vue changée:', dateInfo.view.type, 'isMonthView:', isMonthViewActive);
              // Appliquer immédiatement l'amélioration appropriée pour la vue actuelle
              setTimeout(() => {
                enhanceCalendar(isMonthViewActive);
                if (isMonthViewActive) {
                  enhanceMonthView();
                }
                hideWeekdayNames(); // Masquer les noms des jours à chaque changement de vue
              }, 50);
            }}
            
            {/* Format des en-têtes de jour - afficher uniquement le numéro du jour dans toutes les vues */}
            dayHeaderFormat={{
              weekday: 'narrow',
              day: 'numeric'
            }}
            
            {/* Configuration des différentes vues avec seulement les numéros de jour */}

            views={{
              dayGridMonth: {
                dayHeaderFormat: { day: 'numeric' }, // Juste le numéro du jour
                titleFormat: { month: 'long', year: 'numeric' },
                dayHeaderClassNames: 'month-view-day-header',
                buttonText: 'Mois',
                viewClassNames: 'calendar-month-view'
              },
              timeGridWeek: {
                dayHeaderFormat: { day: 'numeric' }, // Juste le numéro du jour
                titleFormat: { month: 'short', year: 'numeric' },
                buttonText: 'Semaine',
                dayHeaderClassNames: 'week-view-day-header'
              },
              timeGridDay: {
                dayHeaderFormat: { day: 'numeric' }, // Juste le numéro du jour
                titleFormat: { month: 'long', day: 'numeric', year: 'numeric' },
                buttonText: 'Jour',
                dayHeaderClassNames: 'day-view-day-header'
              },
              listWeek: {
                titleFormat: { month: 'long', year: 'numeric' },
                buttonText: 'Planning'
              }
            }}
            lazyFetching={true}
            eventTimeFormat={{
              hour: '2-digit',
              minute: '2-digit',
              hour12: false
            }}
            // Simplifier le rendu des événements pour améliorer les performances
            eventContent={(arg) => {
              // Récupérer le statut pour déterminer les icônes et styles
              const status = arg.event.extendedProps.status;
              
              // Icône en fonction du statut
              let statusIcon = '';
              switch(status) {
                case 'confirmed':
                  statusIcon = '✓';
                  break;
                case 'pending':
                  statusIcon = '⌛';
                  break;
                case 'cancelled':
                  statusIcon = '✕';
                  break;
                case 'completed':
                  statusIcon = '✓✓';
                  break;
                default:
                  statusIcon = '•';
              }
              return (
                <div className="p-1.5 w-full relative overflow-hidden">
                  {/* Ajouter un conteneur de statut en haut à droite */}
                  <div className="absolute top-1 right-1 flex items-center gap-1 z-10">
                    <div className="h-2.5 w-2.5 rounded-full animate-pulse"
                         style={{ backgroundColor: getStatusColor(status) }}></div>
                    <div className="text-sm font-medium opacity-80">
                      {statusIcon}
                    </div>
                  </div>
                  
                  {/* Contenu principal de l'événement avec style amélioré */}
                  <div className="font-semibold truncate text-base mt-1">
                    {arg.event.extendedProps.clientName}
                  </div>
                  <div className="text-sm truncate text-gray-600 dark:text-gray-400 flex items-center">
                    <div className="flex items-center gap-1">
                      <span className="inline-block w-3 h-3 rounded-full"
                            style={{ 
                              backgroundColor: getStatusColor(status),
                              boxShadow: `0 0 3px ${getStatusColor(status)}` 
                            }}></span>
                      <span>{arg.event.extendedProps.serviceName}</span>
                    </div>
                  </div>
                  
                  {/* Durée du RDV (si disponible) */}
                  {arg.event.extendedProps.appointmentData?.duration && (
                    <div className="text-xs text-gray-500 dark:text-gray-500 mt-1">
                      {arg.event.extendedProps.appointmentData.duration} min
                    </div>
                  )}
                </div>
              )
            }}
          />
        </div>
      )}

      {/* Modal pour ajouter un nouveau rendez-vous */}
      {isNewAppointmentModalOpen && (
        <NewAppointmentModal
          isOpen={isNewAppointmentModalOpen}
          onClose={() => {
            console.log("Fermeture du modal nouveau rendez-vous - rechargement des données");
            setIsNewAppointmentModalOpen(false);
            setTimeout(() => {
              loadAppointments(); // Recharger les rendez-vous après la fermeture avec un petit délai
              if (onAppointmentUpdated) {
                onAppointmentUpdated(); // Notification au parent qu'un rendez-vous a été mis à jour
              }
            }, 300);
          }}
          appointment={{
            id: 0,
            clientName: '',
            clientEmail: '',
            clientPhone: '',
            serviceId: 0,
            date: selectedDate,
            time: selectedTime,
            status: 'pending',
            notes: ''
          }}
        />
      )}

      {/* Modal pour éditer un rendez-vous existant */}
      {isEditAppointmentModalOpen && selectedAppointment && (
        <NewAppointmentModal
          isOpen={isEditAppointmentModalOpen}
          onClose={() => {
            console.log("Fermeture du modal édition rendez-vous - rechargement des données");
            setIsEditAppointmentModalOpen(false);
            setTimeout(() => {
              loadAppointments(); // Recharger les rendez-vous après la fermeture avec un petit délai
              if (onAppointmentUpdated) {
                onAppointmentUpdated(); // Notification au parent qu'un rendez-vous a été mis à jour
              }
            }, 300);
          }}
          appointment={selectedAppointment}
          onDelete={async (id: number) => {
            try {
              console.log("Suppression du rendez-vous:", id);
              await appointmentService.delete(id.toString());
              loadAppointments(); // Recharger les rendez-vous après la suppression
              if (onAppointmentUpdated) {
                onAppointmentUpdated(); // Notification au parent qu'un rendez-vous a été mis à jour
              }
            } catch (err) {
              console.error("Erreur lors de la suppression du rendez-vous:", err);
              throw err;
            }
          }}
        />
      )}
    </div>
  );
};

export default AppointmentCalendar;
